rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for authentication and authorization
    function isAuthenticated() {
      return request.auth != null;
    }

    function hasRole(role) {
      return isAuthenticated() && request.auth.token.roles.hasAny([role]);
    }

    function isAdmin() {
      return hasRole('admin');
    }

    function isPropertyManager() {
      return hasRole('property_manager');
    }

    // function isPropertyStaff() {
    //   return hasRole('property_staff');
    // }

    function isResident() {
      return hasRole('resident');
    }

    function isOrgUser(orgId) {
      return isAuthenticated() && request.auth.token.organizationId == orgId;
    }

    function isPropertyResident(orgId, propId) {
      return isAuthenticated() &&
             request.auth.token.organizationId == orgId &&
             request.auth.token.propertyId == propId;
    }

    // Rules for top-level collections
    match /mail/{document=**} {
      // Allow authenticated users to create mail documents (e.g., for sending emails)
      // Admins can read/write all mail documents
      allow read, write: if isAuthenticated();
    }

    match /templates/{document=**} {
      // Allow only admins to read/write email templates
      allow read, write: if isAdmin();
    }

    // The root /users collection is no longer used for storing user profiles.
    // Profiles are stored in /admins/{adminId} or /organizations/{orgId}/users/{userId} or /organizations/{orgId}/properties/{propId}/residents/{residentId}

    match /admins/{adminId} {
      // Only allow admin role to read/write admin profiles
      allow read, write: if isAdmin();
    }

    match /organizations/{organizationId} {
      // Admins can create, read, update, delete organizations
      allow create, read, update, delete: if isAdmin();

      // Organization users can read their own organization's document
      allow read: if isOrgUser(organizationId);

      // Subcollection: users (Property Managers, Staff)
      match /users/{orgUserId} {
        // Admins can manage all organization users
        allow read, write: if isAdmin();
        // Property Managers can manage users within their organization
        allow read, write: if isPropertyManager() && isOrgUser(organizationId);
        // Property Staff can read users within their organization
        allow read: if isPropertyStaff() && isOrgUser(organizationId);
      }

      // Subcollection: properties
      match /properties/{propertyId} {
        // Admins can manage all properties
        allow read, write: if isAdmin();
        // Property Managers can manage properties within their organization
        allow read, write: if isPropertyManager() && isOrgUser(organizationId);
      // Property Staff can read properties within their organization
      allow read: if isPropertyStaff() && isOrgUser(organizationId);
      // Residents can read the specific property they belong to
      allow read: if isResident() && isPropertyResident(organizationId, propertyId);

      // Subcollection: residents
        match /residents/{residentId} {
          // Admins can manage all residents
          allow read, write: if isAdmin();
          // Property Managers can manage residents within their organization and property
          // Note: PMs should typically invite/create residents, and perhaps deactivate. Full write might be too broad.
          // For now, let's assume PMs can manage (read/write) residents of properties they are associated with.
          // This might need refinement based on specific PM permissions for properties.
          allow read, write: if isPropertyManager() && isOrgUser(organizationId); // Simplified for now, assumes PM has org-level access to residents

          // Residents can read their own profile
          allow read: if isResident() && request.auth.uid == residentId && isPropertyResident(organizationId, propertyId);
          // Residents can update specific fields of their own profile
          allow update: if isResident() && request.auth.uid == residentId && isPropertyResident(organizationId, propertyId) &&
                           request.resource.data.keys().hasOnly(['displayName', 'vehicleMake', 'vehicleModel', 'vehicleColor', 'licensePlate'
                           // Add other resident-updatable fields here, e.g. 'contactPreferences'
                           // Critical fields like email, roles, organizationId, propertyId should NOT be updatable by resident directly here.
                           // Ensure that fields not listed here cannot be changed by comparing request.resource.data to resource.data for unchanged fields.
                           ]) &&
                           // Ensure non-updatable fields remain unchanged
                           request.resource.data.email == resource.data.email &&
                           request.resource.data.organizationId == resource.data.organizationId &&
                           request.resource.data.propertyId == resource.data.propertyId &&
                           request.resource.data.roles == resource.data.roles &&
                           request.resource.data.invitedBy == resource.data.invitedBy &&
                           request.resource.data.createdAt == resource.data.createdAt &&
                           (request.resource.data.unitNumber == resource.data.unitNumber || resource.data.unitNumber == null) && // unitNumber might be set by PM
                           (request.resource.data.leaseStartDate == resource.data.leaseStartDate || resource.data.leaseStartDate == null) &&
                           (request.resource.data.leaseEndDate == resource.data.leaseEndDate || resource.data.leaseEndDate == null);
        }
      }

      // Subcollection: invitations
      match /invitations/{invitationId} {
        // Admins can manage all invitations (create, read, update, delete)
        allow read, write: if isAdmin();

        // Property Managers can create invitations within their organization.
        // They can read/update invitations they created or for their organization.
        allow create: if isPropertyManager() && isOrgUser(organizationId) &&
                        request.resource.data.createdBy == request.auth.uid &&
                        request.resource.data.organizationId == organizationId;

        allow read, update: if isPropertyManager() && isOrgUser(organizationId);
        // No direct delete for PMs unless specifically designed (e.g., only for 'pending' ones they created)

        // Public read for a specific invitation token (e.g., when user clicks link before sign-up)
        // This is tricky because unauthenticated users can't be easily granted specific doc access.
        // The `signUpWithInvitation` function will handle token validation server-side.
        // Client-side, if a page needs to display invitation details pre-auth, it would call a function.
        // For now, we assume authenticated reads by PM/Admin cover most UI needs.
        // If unauthenticated read of an invitation is needed, a Cloud Function acting as a proxy would be safer.
      }

      // Subcollection: services
      match /services/{serviceId} {
        allow read, write: if isAdmin(); // Admin full access

        // --- Property Manager/Staff Rules ---
        // GET, UPDATE, DELETE single service document
        allow get, update, delete: if (isPropertyManager() || isPropertyStaff()) &&
                                      isOrgUser(organizationId) &&
                                      resource.data.organizationId == organizationId && 
                                      resource.data.propertyId == request.auth.token.propertyId;

        // LIST services (client query must filter by propertyId for effective scoping by this rule)
        allow list: if (isPropertyManager() || isPropertyStaff()) &&
                       isOrgUser(organizationId) &&
                       request.auth.token.propertyId != null; // Must be associated with a property

        // CREATE service
        allow create: if (isPropertyManager() || isPropertyStaff()) &&
                         isOrgUser(organizationId) &&
                         request.auth.token.propertyId != null &&
                         request.resource.data.organizationId == organizationId &&
                         request.resource.data.propertyId == request.auth.token.propertyId;

        // --- Resident Rules ---
        // CREATE service request
        allow create: if isResident() &&
                         isOrgUser(organizationId) && 
                         request.auth.token.propertyId != null &&
                         request.resource.data.residentId == request.auth.uid &&
                         request.resource.data.organizationId == organizationId &&
                         request.resource.data.propertyId == request.auth.token.propertyId;

        // GET single service request
        allow get: if isResident() &&
                      isOrgUser(organizationId) &&
                      request.auth.token.propertyId != null && // Ensure resident has a property for context
                      resource.data.residentId == request.auth.uid &&
                      resource.data.organizationId == organizationId && 
                      resource.data.propertyId == request.auth.token.propertyId;

        // LIST service requests (client query must filter by residentId)
        allow list: if isResident() &&
                       isOrgUser(organizationId) &&
                       request.auth.token.propertyId != null; // Ensure resident has a property for context

        // UPDATE own service request
        allow update: if isResident() &&
                         isOrgUser(organizationId) &&
                         request.auth.token.propertyId != null && // Ensure resident has a property for context
                         resource.data.residentId == request.auth.uid &&
                         resource.data.organizationId == organizationId && 
                         resource.data.propertyId == request.auth.token.propertyId;
                         // && (add field validation here for what can be updated)
      }
    }
  }
}
